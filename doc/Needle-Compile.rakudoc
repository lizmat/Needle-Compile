=begin pod

=head1 NAME

Needle::Compile - compile a search needle specification

=head1 SYNOPSIS

=begin code :lang<raku>

use Needle::Compile;

my &basic = compile-needle("bar");
say basic("foo bar baz");             # True
say basic("Huey, Dewey, and Louie");  # False

my &capitals-ok = compile-needle("bar", :ignorecase);
say capitals-ok("foo bar baz");             # True
say capitals-ok("FOO BAR BAZ");             # True
say capitals-ok("Huey, Dewey, and Louie");  # False

=end code

=head1 DESCRIPTION

Needle::Compile exports a single subroutine "compile-needle" that takes
a number of arguments that specify a search query needle, and returns a
C<Callable> that can be called with a given haystack to see if there is
a match.

It can as such be used as the argument to the C<rak> subroutine provided
by the L<C<rak>|https://raku.land/zef:lizmat/rak> distribution.

=head1 SEARCH QUERY SPECIFICATION

A query can consist of multiple needles of different types.  A type of
needle can be specified in 3 ways:

=head3 implicitely

=begin code :lang<raku>

# accept haystack if "bar" as word is found
my &needle = compile-needle("§bar");

=end code

By using textual markers at the start and end of the given string needle
(see: type is "auto").

=head3 explicitely

=begin code :lang<raku>

# accept haystack if "bar" as word is found
my &needle = compile-needle("words" => "bar");

=end code

By specifying a needle as a C<Pair>, with the key being a string describing
the type.

=head3 mixed in

=begin code :lang<raku>

my role Type { has $.type }

# accept haystack if "bar" as word is found
my &needle = compile-needle("bar" but Type("words"));

=end code

If the needle specified supports a C<.type> method, then that method will
be called to determine the type.

=head2 Modifiers

Many types of matches support C<ignorecase> and C<ignoremark> semantics.
These can be specified explicitely (with the C<:ignorecase> and
C<:ignoremark> named arguments), or implicitely with the C<:smartcase>
and C<:smartmark> named arguments.

=head3 ignorecase

=begin code :lang<raku>

# accept haystack if "bar" is found, regardless of case
my &needle = compile-needle("bar", :ignorecase);

=end code

Allow characters to match even if they are of mixed case.

=head3 smartcase

=begin code :lang<raku>

# accept haystack if "bar" is found, regardless of case
my &anycase = compile-needle("bar", :smartcase);

# accept haystack if "Bar" is found
my &exactcase = compile-needle("Bar", :smartcase);

=end code

If the needle is a string and does B<not> contain any uppercase characters,
then C<ignorecase> semantics will be assumed.

=head3 ignoremark

=begin code :lang<raku>

# accept haystack if "bar" is found, regardless of any accents
my &anycase = compile-needle("bar", :ignoremark);

=end code

Allow characters to match even if they have accents (or not).

=head3 smartmark

=begin code :lang<raku>

# accept haystack if "bar" is found, regardless of any accents
my &anymark = compile-needle("bar", :smartmark);

# accept haystack if "bår" is found
my &exactmark = compile-needle("bår", :smartcase);

=end code

If the needle is a string and does B<not> contain any characters with accents,
then C<ignoremark> semantics will be assumed.

=head2 Types of matches

=head3 auto

This is the default type of match.  It looks at the given string for a
number of markers, and adjust the type of match and the string accordingly.
The following markers are recognized:

=head4 starts with !

=begin code :lang<raku>

# accept haystack if "bar" is NOT found
my &needle = compile-needle('!bar');

=end code

This is a meta-marker.  Assumes the string given (without the C<!>) should
be processed, and its result negated (see: type is "not")

=head4 starts with §

=begin code :lang<raku>

# accept haystack if "bar" is found as a word
my &needle = compile-needle('§bar');

=end code

Assumes the string given (without the C<§>) should match with
word-boundary semantics applied (see: type is "words").

=head4 starts with *

=begin code :lang<raku>

# accept haystack if alphabetically before "bar"
my &is-before = compile-needle('* before "bar"');

# return every haystack uppercased
my &uppercased = compile-needle('*.uc');

=end code

Assumes the given string is a valid C<WhateverCode> specification and
attempts to produce that specification accordingly (see: type is "code").

=head4 starts with jp:

=begin code :lang<raku>

# return result of JSON::Path query "auth"
my &needle = compile-needle('jp:auth');

=end code

Assumes the given string (without the C<jp:> prefix) is a valid
L<C<JSON Path>|https://en.wikipedia.org/wiki/JSONPath> specification
(see: type is "json-path").

=head4 starts with ^

=begin code :lang<raku>

# accept haystack if it starts with "bar"
my &needle = compile-needle('^bar');

=end code

Assumes the string given (without the C<^>) should match with
C<.starts-with> semantics applied (see: type is "starts-with").

=head4 ends with $

=begin code :lang<raku>

# accept haystack if it ends with "bar"
my &needle = compile-needle('bar$');

=end code

Assumes the string given (without the C<$>) should match with
C<.ends-with> semantics applied (see: type is "ends-with").

=head4 starts with ^ and ends with $

=begin code :lang<raku>

# accept haystack if it is equal to "bar"
my &needle = compile-needle('^bar$');

=end code

Assumes the string given (without the C<^> and C<$>) should match exactly
(see: type is "equal").

=head4 starts with / and ends with /

=begin code :lang<raku>

# accept haystack if it matches "bar" as a regular expression
my &needle = compile-needle('/bar/');

=end code

Assumes the string given (without the C</>'s) is a regex and attempts
to produce a C<Regex> object and wraps that in a call to C<.contains>
(see: type is "regex").

=head4 starts with { and ends with }

=begin code :lang<raku>

# return the lowercased, whitespace trimmed haystack
my &needle = compile-needle('{.trim.lc}');

=end code

Assumes the string given (without the C<{> and C<}>) is an expression
and attempts to produce the code (see: type is "code").

=head4 none of the above

=begin code :lang<raku>

# accept haystack if it contains "bar"
my &needle = compile-needle("bar");

=end code

Assumes the string given should match with C<.contains> semantics
applied (see: type is "contains").

=head3 code

=begin code :lang<raku>

# return uppercase version of the haystack
my &needle = compile-needle("code" => ".uc");

=end code

Assumes the string is an expression and attempts to produce that code,
with the haystack being presented as the topic (C<$_>).

To facilitate the use of libraries that wish to access that topic, it
is also available as the C<$*_> dynamic variable.

=head3 contains

=begin code :lang<raku>

# accept haystack if it contains "bar"
my &needle = compile-needle("contains" => "bar");

=end code

Assumes the string is a needle in a call to C<.contains>.

=head3 ends-with

=begin code :lang<raku>

# accept haystack if it ends with "bar"
my &needle = compile-needle("ends-with" => "bar");

=end code

Assumes the string is a needle in a call to C<.ends-with>.

=head3 equal

=begin code :lang<raku>

# accept haystack if it is equal to "bar"
my &needle = compile-needle("equal" => "bar");

=end code

Assumes the string is a needle to compare with the haystack using infix
C<eq> semantics.

=head3 json-path

=begin code :lang<raku>

# return result of JSON::Path query "auth"
my &needle = compile-needle("json-path" => 'auth');

=end code

Assumes the given string is a valid
L<C<JSON Path>|https://en.wikipedia.org/wiki/JSONPath> specification.

Must have the L<C<JSON::Path>|https://raku.land/cpan:JNTHN/JSON::Path>
module installed.

The generated C<Callable> will expect an C<Associative> haystack (aka, a
<Hash>) to be passed, and will return a C<Slip> with any results.

=begin code :lang<raku>

# return result of JSON::Path query "auth"
my &needle = compile-needle({ jp('auth').Slip });

=end code

Alternately, you can also the C<jp()> function.  This returns a specialized
C<JP> object.  Note that simply specifying a call to the C<jp> function is
not enough: one must do something with it.  In the above example calling
C<.Slip> will cause the actual querying to happen.

See "Doing JSON path queries in code needles" for more information.

=head3 not

=begin code :lang<raku>

# accept haystack if "bar" is NOT found
my &needle = compile-needle("not" => "bar");

=end code

This is a meta-type: it inverts the result of the result of matching
of the given needle (which can be anything otherwise acceptable).

=head3 regex

=begin code :lang<raku>

# accept haystack if "bar" is found
my &needle = compile-needle("regex" => "bar");

=end code

Assumes the string is a regex specification to be used as a needle in a
call to C<.contains>.

=head3 starts-with

=begin code :lang<raku>

# accept haystack if it starts with "bar"
my &needle = compile-needle("starts-with" => "bar");

=end code

Assumes the string is a needle in a call to C<.starts-with>.

=head3 words

=begin code :lang<raku>

# accept haystack if "bar" is found as a word
my &needle = compile-needle("words" => "bar");

=end code

Assumes the string is a needle that will match if the needle is found
with word boundaries on either side of the needle.

=head2 Doing JSON path queries in code needles

=begin code :lang<raku>

# return result of JSON::Path query "auth"
my &needle = compile-needle({ jp('auth').Slip });

=end code

The initial call to the C<jp> function will attempt to load the
C<JSON::Path> module, and fail if it cannot.  If the load is successful,
it will create an object of the (internal) C<JP> class with the giveni
pattern.

If the C<JSON::Path> module was already loaded, it will either produce
the C<JP> object from a cache, or create a new C<JP> object.

The object as such, does nothing.  It needs to have a method called on
it B<within the scope of the code needle> to properly function.

If you're using the (implicit) C<"json-path"> type for your needle, this
is done automatically for you, by calling the C<.Slip> method on it.

The following methods can be called on the C<JP> object:

=table
  method             selected
  ---------------------------
  .value             The first selected value
  .values            All selected values as a Seq
  .paths             The paths of all selected values as a Seq
  .paths-and-values  Interleaved selected paths and values
  .words             All words in selected values as a Slip
  .head              The first N selected values as a Slip
  .tail              The last N selected values as a Slip
  .skip              Skip N selected values, produce rest as a Slip
  .Seq               All selected values as a Seq
  .Bool              True if any values selected, else False
  .List              All selected values as a List
  .Slip              All selected values as a Slip
  .gist              All selected values stringified as a gist
  .Str               All selected values stringified

=begin code :lang<raku>

# return first and third result of JSON::Path query "auth" as a Slip
my &needle = compile-needle({ jp('auth')[0,2] });

=end code

Furthermore, you can use postcircumfix C<[ ]> on the C<JP> object to
select values from the result.

=head1 AUTHOR

Elizabeth Mattijsen <liz@raku.rocks>

Source can be located at: https://github.com/lizmat/Needle-Compile .
Comments and Pull Requests are welcome.

If you like this module, or what I’m doing more generally, committing to a
L<small sponsorship|https://github.com/sponsors/lizmat/>  would mean a great
deal to me!

=head1 COPYRIGHT AND LICENSE

Copyright 2024 Elizabeth Mattijsen

This library is free software; you can redistribute it and/or modify it under the Artistic License 2.0.

=end pod

# vim: expandtab shiftwidth=4
