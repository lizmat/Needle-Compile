=begin pod

=head1 NAME

Needle::Compile - compile a search needle specification

=head1 SYNOPSIS

=begin code :lang<raku>

use Needle::Compile;

my &basic = compile-needle("bar");
say basic("foo bar baz");             # True
say basic("Huey, Dewey, and Louie");  # False

my &capitals-ok = compile-needle("bar", :ignorecase);
say capitals-ok("foo bar baz");             # True
say capitals-ok("FOO BAR BAZ");             # True
say capitals-ok("Huey, Dewey, and Louie");  # False

=end code

=head1 DESCRIPTION

Needle::Compile exports a single subroutine "compile-needle" that takes
a number of arguments that specify a search query needle, and returns a
C<Callable> that can be called with a given haystack to see if there is
a match.

It can as such be used as the argument to the C<rak> subroutine provided
by the L<C<rak>|https://raku.land/zef:lizmat/rak> distribution.

=head1 SEARCH QUERY SPECIFICATION

A query can consist of multiple needles of different types.  A type of
needle can be specified in 3 ways:

=head3 implicitely

=begin code :lang<raku>

# accept haystack if "bar" as word is found
my &needle = compile-needle("§bar");

=end code

By using textual markers at the start and end of the given string needle
(see: type is "auto").

=head3 explicitely

=begin code :lang<raku>

# accept haystack if "bar" as word is found
my &needle = compile-needle("words" => "bar");

=end code

By specifying a needle as a C<Pair>, with the key being a string describing
the type.

=head3 mixed in

=begin code :lang<raku>

my role Type { has $.type }

# accept haystack if "bar" as word is found
my &needle = compile-needle("bar" but Type("words"));

=end code

If the needle specified supports a C<.type> method, then that method will
be called to determine the type.

=head2 Modifiers

Many types of matches support C<ignorecase> and C<ignoremark> semantics.
These can be specified explicitely (with the C<:ignorecase> and
C<:ignoremark> named arguments), or implicitely with the C<:smartcase>
and C<:smartmark> named arguments.

=head3 ignorecase

=begin code :lang<raku>

# accept haystack if "bar" is found, regardless of case
my &needle = compile-needle("bar", :ignorecase);

=end code

Allow characters to match even if they are of mixed case.

=head3 smartcase

=begin code :lang<raku>

# accept haystack if "bar" is found, regardless of case
my &anycase = compile-needle("bar", :smartcase);

# accept haystack if "Bar" is found
my &exactcase = compile-needle("Bar", :smartcase);

=end code

If the needle is a string and does B<not> contain any uppercase characters,
then C<ignorecase> semantics will be assumed.

=head3 ignoremark

=begin code :lang<raku>

# accept haystack if "bar" is found, regardless of any accents
my &anycase = compile-needle("bar", :ignoremark);

=end code

Allow characters to match even if they have accents (or not).

=head3 smartmark

=begin code :lang<raku>

# accept haystack if "bar" is found, regardless of any accents
my &anymark = compile-needle("bar", :smartmark);

# accept haystack if "bår" is found
my &exactmark = compile-needle("bår", :smartcase);

=end code

If the needle is a string and does B<not> contain any characters with accents,
then C<ignoremark> semantics will be assumed.

=head2 Types of matches

=head3 auto

This is the default type of match.  It looks at the given string for a
number of markers, and adjust the type of match and the string accordingly.
The following markers are recognized:

=head4 starts with !

=begin code :lang<raku>

# accept haystack if "bar" is NOT found
my &needle = compile-needle('!bar');

=end code

This is a meta-marker.  Assumes the string given (without the C<!>) should
be processed, and its result negated (see: type is "not")

=head4 starts with §

=begin code :lang<raku>

# accept haystack if "bar" is found as a word
my &needle = compile-needle('§bar');

=end code

Assumes the string given (without the C<§>) should match with
word-boundary semantics applied (see: type is "words").

=head4 starts with *

=begin code :lang<raku>

# accept haystack if alphabetically before "bar"
my &is-before = compile-needle('* before "bar"');

# return every haystack uppercased
my &uppercased = compile-needle('*.uc');

=end code

Assumes the given string is a valid C<WhateverCode> specification and
attempts to produce that specification accordingly (see: type is "code").

=head4 starts with ^

=begin code :lang<raku>

# accept haystack if it starts with "bar"
my &needle = compile-needle('^bar');

=end code

Assumes the string given (without the C<^>) should match with
C<.starts-with> semantics applied (see: type is "starts-with").

=head4 ends with $

=begin code :lang<raku>

# accept haystack if it ends with "bar"
my &needle = compile-needle('bar$');

=end code

Assumes the string given (without the C<$>) should match with
C<.ends-with> semantics applied (see: type is "ends-with").

=head4 starts with ^ and ends with $

=begin code :lang<raku>

# accept haystack if it is equal to "bar"
my &needle = compile-needle('^bar$');

=end code

Assumes the string given (without the C<^> and C<$>) should match exactly
(see: type is "equal").

=head4 starts with / and ends with /

=begin code :lang<raku>

# accept haystack if it matches "bar" as a regular expression
my &needle = compile-needle('/bar/');

=end code

Assumes the string given (without the C</>'s) is a regex and attempts
to produce a C<Regex> object and wraps that in a call to C<.contains>
(see: type is "regex").

=head4 starts with { and ends with }

=begin code :lang<raku>

# return the lowercased, whitespace trimmed haystack
my &needle = compile-needle('{.trim.lc}');

=end code

Assumes the string given (without the C<{> and C<}>) is an expression
and attempts to produce the code (see: type is "code").

=head4 none of the above

=begin code :lang<raku>

# accept haystack if it contains "bar"
my &needle = compile-needle("bar");

=end code

Assumes the string given should match with C<.contains> semantics
applied (see: type is "contains").

=head3 code

=begin code :lang<raku>

# return uppercase version of the haystack
my &needle = compile-needle("code" => ".uc");

=end code

Assumes the string is an expression and attempts to produce that code,
with the haystack being presented as the topic (C<$_>).

=head3 contains

=begin code :lang<raku>

# accept haystack if it contains "bar"
my &needle = compile-needle("contains" => "bar");

=end code

Assumes the string is a needle in a call to C<.contains>.

=head3 ends-with

=begin code :lang<raku>

# accept haystack if it ends with "bar"
my &needle = compile-needle("ends-with" => "bar");

=end code

Assumes the string is a needle in a call to C<.ends-with>.

=head3 equal

=begin code :lang<raku>

# accept haystack if it is equal to "bar"
my &needle = compile-needle("equal" => "bar");

=end code

Assumes the string is a needle to compare with the haystack using infix
C<eq> semantics.

=head3 not

=begin code :lang<raku>

# accept haystack if "bar" is NOT found
my &needle = compile-needle("not" => "bar");

=end code

This is a meta-type: it inverts the result of the result of matching
of the given needle (which can be anything otherwise acceptable).

=head3 regex

=begin code :lang<raku>

# accept haystack if "bar" is found
my &needle = compile-needle("regex" => "bar");

=end code

Assumes the string is a regex specification to be used as a needle in a
call to C<.contains>.

=head3 starts-with

=begin code :lang<raku>

# accept haystack if it starts with "bar"
my &needle = compile-needle("starts-with" => "bar");

=end code

Assumes the string is a needle in a call to C<.starts-with>.

=head3 words

=begin code :lang<raku>

# accept haystack if "bar" is found as a word
my &needle = compile-needle("words" => "bar");

=end code

Assumes the string is a needle that will match if the needle is found
with word boundaries on eiher side of the needle.

=head1 AUTHOR

Elizabeth Mattijsen <liz@raku.rocks>

Source can be located at: https://github.com/lizmat/Needle-Compile .
Comments and Pull Requests are welcome.

If you like this module, or what I’m doing more generally, committing to a
L<small sponsorship|https://github.com/sponsors/lizmat/>  would mean a great
deal to me!

=head1 COPYRIGHT AND LICENSE

Copyright 2024 Elizabeth Mattijsen

This library is free software; you can redistribute it and/or modify it under the Artistic License 2.0.

=end pod

# vim: expandtab shiftwidth=4
